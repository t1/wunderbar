= BAR :: Behaviour ARchive image:https://maven-badges.herokuapp.com/maven-central/com.github.t1/wunderbar/badge.svg[link=https://search.maven.org/artifact/com.github.t1/wunderbar] image:https://github.com/t1/wunderbar/actions/workflows/maven.yml/badge.svg[link=https://github.com/t1/wunderbar/actions/workflows/maven.yml]

Low ceremony https://martinfowler.com/articles/consumerDrivenContracts.html[Consumer Driven Contracts] for Java natives. Supports REST and https://graphql.org[GraphQL].

Just to make it clear: just because the consumer drives the contract doesn't mean that the provider is expected to comply blindly. It's only a starting point for the contract negotiation. The provider has to evolve a domain model that is consistent over all consumers: the BAR files are not a replacement for talking; they just augment it by the precision required by the machines.

== 2 Minute Intro (REST)

Say you're developing an Order system that uses data from a Product service.

You probably write unit tests with Mockito:

[source,java]
----
@ExtendWith(MockitoExtension.class)
class ProductsRestGatewayMockitoTest {
    @Mock ProductsRestClient products;
    @InjectMocks ProductsRestGateway gateway;

    @Test void shouldGetProduct() {
        given(products.product(PRODUCT_ID)).willReturn(PRODUCT);

        var response = gateway.product(ITEM);

        then(response).usingRecursiveComparison().isEqualTo(PRODUCT);
    }
}
----

Instead of these annotations (and the static `given` method import), you can use different ones. Same concepts, same (but limited) behavior, just different logs:

[source,java]
----
@WunderBarConsumerExtension
class ProductsRestGatewayTest {
    @Service ProductsRestClient products;
    @SystemUnderTest ProductsRestGateway gateway;

    @Test void shouldGetProduct() {
        given(products.product(PRODUCT_ID)).willReturn(PRODUCT);

        var response = gateway.product(ITEM);

        then(response).usingRecursiveComparison().isEqualTo(PRODUCT);
    }
}
----

It starts to get interesting, when you change the `WunderBarApiConsumer` annotation to `@WunderBarConsumerExtension(level = INTEGRATION)` (or simply change the test name to end with `IT`, short for Integration Test): the extension now starts a mock server exposing the behavior you just stubbed, i.e. it will reply to your REST request with the proper product. No code changes needed, and it fully tests your client annotations and (de)serialization of your POJOs.

Now comes the interesting part: it records the requests and responses you need for your code to work, and saves it in a `wunder.bar` file (Behavior ARchive). Give this file to your service implementers, maybe by deploying it together with your other maven artefacts, so they can check if their service complies to your requirements. To do so, they load the tests stored in a `wunder.bar` file and run them against their service:

[source,java]
----
@WunderBarApiProvider(baseUri = "http://localhost:8080")
class ConsumerDrivenAT {
    @TestFactory DynamicNode demoOrderConsumerTests() {
        return findTestsIn("wunder.bar");
    }
}
----

JUnit-Jupiter calls `@BeforeEach` and `@AfterEach` methods only once before/after a `@TestFactory`, but you can use `@BeforeDynamicTest` / `@AfterDynamicTest` to set up and clean up the data you need in your service to match the requirements. Those methods can get a `List<HttpServerInteraction> interactions` parameter to do this job.

Writing your acceptance tests in this way makes testing more robust, as you don't have to agree with the consumers of your APIs on any volatile and intransparent assumptions about the test data, e.g. what ids result in what behavior.

== Documentation

The Documentation is in the JavaDoc, mainly of the annotations https://github.com/t1/wunderbar/blob/master/junit/src/main/java/com/github/t1/wunderbar/junit/consumer/WunderBarConsumerExtension.java[`@WunderBarConsumerExtension`] and the https://github.com/t1/wunderbar/blob/master/junit/src/main/java/com/github/t1/wunderbar/junit/consumer/Level.java[`Level`] annotation for the API consumer (client) side and https://github.com/t1/wunderbar/blob/master/junit/src/main/java/com/github/t1/wunderbar/junit/provider/WunderBarApiProvider.java[`@WunderBarApiProvider`] for the API provider (server) side.

The `demo` module contains two example projects: `order` consumes an API that is implemented by the `product` service. Both in REST and GraphQL and on all test levels.
