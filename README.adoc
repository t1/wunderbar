= BAR :: Behaviour ARchive image:https://maven-badges.herokuapp.com/maven-central/com.github.t1/wunderbar/badge.svg[link=https://search.maven.org/artifact/com.github.t1/wunderbar] image:https://github.com/t1/wunderbar/actions/workflows/maven.yml/badge.svg[link=https://github.com/t1/wunderbar/actions/workflows/maven.yml]

Low ceremony, code-first https://martinfowler.com/articles/consumerDrivenContracts.html[Consumer Driven Contracts] for Java natives. Supports REST (via https://github.com/eclipse/microprofile-rest-client[MicroProfile REST Client]) and https://graphql.org[GraphQL] (via https://github.com/smallrye/smallrye-graphql/tree/master/client/api[SmallRye GraphQL Client]).

Just to make it clear: just because the consumer drives the contract doesn't mean that the provider is expected to comply blindly. It's only a starting point for the contract negotiation. The provider has to evolve a domain model that is consistent over all consumers: the BAR files are not a replacement for talking; they just augment it by the precision required by the machines. And starting from the API Consumer perspective is actually just a very natural way of defining an API: from the real requirements.

== 2 Minute Intro (REST)

Say you're developing an Order system that uses data from a Product service.

You probably write unit tests with Mockito:

[source,java]
----
@ExtendWith(MockitoExtension.class)
class ProductsRestGatewayMockitoTest {
    @Mock ProductsRestClient products;
    @InjectMocks ProductsRestGateway gateway;

    @Test void shouldGetProduct() {
        given(products.product(PRODUCT_ID)).willReturn(PRODUCT);

        var response = gateway.product(ITEM);

        then(response).usingRecursiveComparison().isEqualTo(PRODUCT);
    }
}
----

Instead of these annotations (and the static `given` method import), you can use different ones. They are more limited than Mockito, but have the same concepts, same behavior, just different logs:

[source,java]
----
@WunderBarConsumerExtension
class ProductsRestGatewayTest {
    @Service ProductsRestClient products;
    @SystemUnderTest ProductsRestGateway gateway;

    @Test void shouldGetProduct() {
        given(products.product(PRODUCT_ID)).willReturn(PRODUCT);

        var response = gateway.product(ITEM);

        then(response).usingRecursiveComparison().isEqualTo(PRODUCT);
    }
}
----

When you change the `WunderBarApiConsumer` annotation to `@WunderBarConsumerExtension(level = INTEGRATION)` (or simply change the test name to end with `IT`, short for Integration Test): the extension now starts a mock server exposing the behavior you just stubbed, i.e. it will reply to your REST request with the proper product. No code changes needed, and it fully tests your REST or GraphQL client annotations and (de)serialization of your POJOs.

This is nice, but the really interesting part is, that it records the requests and responses you need for your code to work, and saves it in a `wunder.bar` file (Behavior ARchive). Give this file to your API provider, maybe by deploying it together with your other maven artefacts, so they can check if their service complies to your requirements.

When you develop an API provider, you load the tests stored in a `wunder.bar` file and run them against your service:

[source,java]
----
@WunderBarApiProvider(baseUri = "http://localhost:8080")
class ConsumerDrivenAT {
    @TestFactory DynamicNode demoOrderConsumerTests() {
        return findTestsIn("wunder.bar");
    }
}
----

== Test Data Management

Managing the data needed for tests is often a complex issue. BARs generated by system tests contain data that existed when it ran. If that data still exists and is in the same state, it doesn't have to be generated. But test data is often changed or even deleted for various reasons: some data simply times out, other data is changed by manual tests, etc. Coordinating this is difficult and requires communication between different teams, resulting in this kind of tests being brittle: they sporadically break without exposing a bug anywhere.

Integration test never touch a real system, though, so the data they expect doesn't exist in the real (test) system. You'll need to set up and clean up the data in your service to match the requirements, maybe by storing and deleting them directly in a database, or by using some backdoor API in your service. You can do so in methods annotated as `@BeforeInteraction` / `@AfterInteraction`; they have the scope of a single interaction within a test and can take a single interaction as a parameter. A `@BeforeInteraction` method can also return an `HttpInteraction`, a `HttpRequest`, or a `HttpResponse` to modify the interaction, e.g. to replace the dummy credentials (xref:credentials[see below]) with real credentials that your service will accept, or to replace the expected id with the id of a new instance generated for this test run.

Writing your acceptance tests in this way makes testing more robust, as you don't have to agree with the consumers of your APIs on any volatile and intransparent assumptions about the test data, e.g. what ids result in what behavior.

== Documentation

The Documentation is in the JavaDoc, mainly of the annotations https://github.com/t1/wunderbar/blob/master/junit/src/main/java/com/github/t1/wunderbar/junit/consumer/WunderBarApiConsumer.java[`@WunderBarApiConsumer`] annotation and the https://github.com/t1/wunderbar/blob/master/junit/src/main/java/com/github/t1/wunderbar/junit/consumer/Level.java[`Level`] enum and the https://github.com/t1/wunderbar/blob/main/junit/src/main/java/com/github/t1/wunderbar/junit/consumer/WunderbarExpectationBuilder.java[`WunderbarExpectationBuilder`] for the API consumer (client) side and https://github.com/t1/wunderbar/blob/master/junit/src/main/java/com/github/t1/wunderbar/junit/provider/WunderBarApiProvider.java[`@WunderBarApiProvider`] for the API provider (server) side.

The `demo` module contains two example projects: `order` consumes an API that the `product` service provides. Both in REST and GraphQL and on all test levels.

[#credentials]
== Credentials

On the API Consumer side, the `bar` files never contain the value of a real `Authorization` header. They could contain dummy values for integration tests, but they don't add any benefit; for system tests, the interactions would even contain real credentials. So only dummy values are ever written instead.

For a GraphQL client, you can use the `@AuthorizationHeader` annotation to read the configuration from an MP Config property; but you don't have to actually provide those for an integration test, as they won't be written anyway; a dummy value will be configured on the fly. OTOH, a `@Header(name = "Authorization")` works normally (but won't be written either).

On the API Provider side, the acceptance test has to replace this value with real credentials, e.g. by returning a modified `HttpRequest` in a `@BeforeInteraction` method.

== Ports

WunderBar uses random ports to distinguish the different expectations. You can find the actually used port from the URI set in the `WunderbarExpectationBuilder#whileSettingBaseUri` method, i.e.

[source,java]
-----
@WunderBarApiConsumer
class ProductResolverIT {
    // ...

    @Test void shouldSetBaseUri() {
        var baseUri = new AtomicReference<URI>();
        given(products.product("1"))
            .whileSettingBaseUri(baseUri::set)
            .willReturn(givenProduct);

        then(baseUri.get().toString()).startsWith("http://localhost:");
    }
}
-----
