= BAR :: Behaviour ARchive =

Low ceremony https://martinfowler.com/articles/consumerDrivenContracts.html[Consumer Driven Contracts] for Java natives.

Supports REST and GraphQL.

== 2 Minute Intro

Say you're developing an Order system that uses data from a Product service.

You probably write unit tests with Mockito:

[source,java]
----
@ExtendWith(MockitoExtension.class)
class ProductsRestGatewayMockitoTest {
    @Mock ProductsRestClient products;
    @InjectMocks ProductsRestGateway gateway;

    @Test void shouldGetProduct() {
        given(products.product(PRODUCT_ID)).willReturn(PRODUCT);

        var response = gateway.product(ITEM);

        then(response).usingRecursiveComparison().isEqualTo(PRODUCT);
    }
}
----

Instead of these annotations (and the `given` method), you can use different ones. Same concepts, same behavior, just different logs:

[source,java]
----
@WunderBarConsumerExtension
class ProductsRestGatewayTest {
    @Service ProductsRestClient products;
    @SystemUnderTest ProductsRestGateway gateway;

    @Test void shouldGetProduct() {
        given(products.product(PRODUCT_ID)).willReturn(PRODUCT);

        var response = gateway.product(ITEM);

        then(response).usingRecursiveComparison().isEqualTo(PRODUCT);
    }
}
----

The interesting part comes, when you change the `@WunderBarConsumerExtension` annotation to `@WunderBarConsumerExtension(level = INTEGRATION)` (or simply change the test name to end with `IT`): the extension now starts a mock server exposing the behavior you just stubbed, i.e. it will reply to your REST request with the proper product. No code changes needed, and it fully tests your client annotations and (de)serialization of your POJOs.

What's even better: it records the requests and responses you need for your code to work, and saves it in a `wunder.bar` file (behavior archive). Give this file to your service implementer (maybe together with your other maven artefacts), so they can check if their service adheres to your requirements.

If you need to implement the service, you load the tests stored in a `wunder.bar` file and run them against your service:

[source,java]
----
@WunderBarRunnerExtension(baseUri = "http://localhost:8080")
class ConsumerDrivenAT {
    @TestFactory DynamicNode demoOrderConsumerTests() {
        return findTestsIn("wunder.bar");
    }
}
----

JUnit-Jupiter calls `@BeforeEach` and `@AfterEach` methods only once before/after a `@TestFactory`, but you can use `@BeforeDynamicTest` / `@AfterDynamicTest` to set up and clean up the data you need in your service to comply with the requirements. Those methods get a `List<HttpServerInteraction> interactions` parameter to do this job.

Writing your acceptance tests in this way makes testing more robust, as you don't have to agree with the consumers of your APIs on any volatile and intransparent assumptions about the test data, e.g. what ids result in what behavior.
