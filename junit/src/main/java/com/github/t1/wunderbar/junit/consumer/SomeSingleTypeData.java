package com.github.t1.wunderbar.junit.consumer;

import java.lang.reflect.AnnotatedElement;
import java.lang.reflect.ParameterizedType;
import java.lang.reflect.Type;

/**
 * Convenience {@link SomeData} class to generate values of a single type automatically derived from
 * the generic type parameter <code>T</code>.
 * You just need to override the {@link #some(Some, Type, AnnotatedElement)} method.
 * <p>
 * This also works for generic types, e.g. a type <code>CustomGeneric&lt;?&gt;</code> can be generated by a
 * <code>class CustomGenericGenerator extends SomeSingleTypeData&lt;CustomGeneric&lt;?&gt;&gt;</code>; the <code>Type</code>
 * parameter of the {@link #some(Some, Type, AnnotatedElement)} method can then safely cast, i.e.
 * <code>var nestedType = ((ParameterizedType) type).getActualTypeArguments()[0];</code>
 */
@SuppressWarnings("unchecked")
public abstract class SomeSingleTypeData<T> implements SomeData {
    protected final Class<T> type;

    public SomeSingleTypeData() {
        var typeOfT = ((ParameterizedType) this.getClass().getGenericSuperclass()).getActualTypeArguments()[0];
        this.type = (Class<T>) ((typeOfT instanceof ParameterizedType) ? rawType(typeOfT) : typeOfT);
    }

    @Override public boolean canGenerate(Some some, Type type, AnnotatedElement location) {
        if (type instanceof ParameterizedType) type = rawType(type);
        return this.type.equals(type);
    }

    private static Type rawType(Type type) {return ((ParameterizedType) type).getRawType();}

    @Override public abstract T some(Some some, Type type, AnnotatedElement location);
}
