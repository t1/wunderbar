package com.github.t1.wunderbar.junit.consumer;

import com.github.t1.wunderbar.junit.WunderBarException;

import java.lang.reflect.AnnotatedElement;
import java.lang.reflect.AnnotatedParameterizedType;
import java.lang.reflect.ParameterizedType;
import java.lang.reflect.Type;
import java.util.Arrays;
import java.util.Optional;
import java.util.stream.Stream;

/**
 * Convenience {@link SomeData} class to generate values of a single type automatically derived from
 * the generic type parameter <code>T</code>.
 * You just need to override the {@link #some(Some, Type, AnnotatedElement)} method.
 * <p>
 * A common use-case is that you want your generator to work only for some tags in <code>@Some</code>.
 * To do so, you can simply annotate the type parameter like this:
 * <pre>
 * class CustomId extends SomeSingleTypes<&#064;Some("id") String> {
 *     public String some(Some some, Type type, AnnotatedElement location) {
 *         return "custom-id";
 *     }
 * }
 * </pre>
 * <p>
 * This also works for generic types, e.g. a type <code>CustomGeneric&lt;?&gt;</code> can be generated by a
 * <code>class CustomGenericGenerator extends SomeSingleTypes&lt;CustomGeneric&lt;?&gt;&gt;</code>.
 * You can then safely cast the <code>Type</code> parameter in your <code>some</code> method,
 * e.g. <code>var nestedType = ((ParameterizedType) type).getActualTypeArguments()[0];</code>
 */
@SuppressWarnings("unchecked")
public abstract class SomeSingleTypes<T> implements SomeData {
    protected final Class<T> type;
    protected final Some some;

    public SomeSingleTypes() {
        var typeOfT = ((ParameterizedType) this.getClass().getGenericSuperclass()).getActualTypeArguments()[0];
        this.type = (Class<T>) ((typeOfT instanceof ParameterizedType) ? rawType(typeOfT) : typeOfT);
        this.some = ((AnnotatedParameterizedType) this.getClass().getAnnotatedSuperclass())
            .getAnnotatedActualTypeArguments()[0].getAnnotation(Some.class);
    }

    @Override public Optional<T> some(Some some, Type type, AnnotatedElement location) {
        var maybeRawType = (type instanceof ParameterizedType) ? rawType(type) : type;
        if (this.type.equals(maybeRawType) && matches(some)) {
            var value = generate(some, type, location);
            if (value == null) throw new WunderBarException(
                "[" + this + "] generated a null value" + ((location == null) ? "" : " for " + location));
            return Optional.of(value);
        } else return Optional.empty();
    }

    private boolean matches(Some some) {
        if (this.some == null) return true;
        if (some == null) return this.some.value().length == 0;
        var actual = Arrays.asList(some.value());
        return Stream.of(this.some.value()).allMatch(actual::contains);
    }

    private static Type rawType(Type type) {return ((ParameterizedType) type).getRawType();}

    public abstract T generate(Some some, Type type, AnnotatedElement location);
}
